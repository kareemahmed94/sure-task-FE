{"remainingRequest":"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/babel-loader/lib/index.js!/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/cache-loader/dist/cjs.js","mtime":1617458485530},{"path":"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/babel-loader/lib/index.js","mtime":1529635966000}],"contextDependencies":[],"result":["import _objectSpread from \"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/@babel/runtime/helpers/builtin/es6/objectSpread\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.string.trim\";\nimport _slicedToArray from \"/Users/kareem/Desktop/dev/kareem/shore/vue-starter/node_modules/@babel/runtime/helpers/builtin/es6/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/web.dom.iterable\";\nimport { camelize, wrapInArray } from './helpers';\nvar pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  var styleMap = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = style.split(pattern.styleList)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var s = _step.value;\n\n      var _s$split = s.split(pattern.styleProp),\n          _s$split2 = _slicedToArray(_s$split, 2),\n          key = _s$split2[0],\n          val = _s$split2[1];\n\n      key = key.trim();\n\n      if (!key) {\n        continue;\n      } // May be undefined if the `key: value` pair is incomplete.\n\n\n      if (typeof val === 'string') {\n        val = val.trim();\n      }\n\n      styleMap[camelize(key)] = val;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  var mergeTarget = {};\n  var i = arguments.length;\n  var prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    var _arr = Object.keys(arguments[i]);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      prop = _arr[_i];\n\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = _objectSpread({}, arguments[i][prop], mergeTarget[prop]);\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners() {\n  if (!(arguments.length <= 0 ? undefined : arguments[0])) return arguments.length <= 1 ? undefined : arguments[1];\n  if (!(arguments.length <= 1 ? undefined : arguments[1])) return arguments.length <= 0 ? undefined : arguments[0];\n  var dest = {};\n\n  for (var i = 2; i--;) {\n    var arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n    for (var event in arg) {\n      if (!arg[event]) continue;\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n\n  return dest;\n} //# sourceMappingURL=mergeData.js.map",{"version":3,"sources":["node_modules/vuetify/lib/util/mergeData.js"],"names":["camelize","wrapInArray","pattern","styleList","styleProp","parseStyle","style","styleMap","split","s","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","dest","arg","event"],"mappings":"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","sourceRoot":"/Users/kareem/Desktop/dev/kareem/shore/vue-starter","sourcesContent":["import { camelize, wrapInArray } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  const styleMap = {};\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n\n    styleMap[camelize(key)] = val;\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners(...args) {\n  if (!args[0]) return args[1];\n  if (!args[1]) return args[0];\n  const dest = {};\n\n  for (let i = 2; i--;) {\n    const arg = args[i];\n\n    for (const event in arg) {\n      if (!arg[event]) continue;\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n\n  return dest;\n}\n//# sourceMappingURL=mergeData.js.map"]}]}